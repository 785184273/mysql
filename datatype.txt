	小数型
	带有小数点或者范围超出整型的数值类型
	sql中，将小数型细分为两种，浮点型和定点型
		浮点型：小数点浮动，精度有限，而且会丢失精度
		定点型：小数点固定，精度固定，不会丢失精度
	浮点型
		是一种精度型数据，因为超出指定范围之后会丢失精度(自动四舍五入)
		浮点型理论分为两种精度
			float:单精度，占用4个字节存储数据，精度范围大概为7个左右
			double：双精度，占用8个字节存储数据，精度范围大概是15位左右
		练习
		创建浮点数表：浮点的使用方式，直接float表示没有小数部分，float(M,D):M代表总长度,D是小数部分的长度,整数部分长度是M-D
		create table tb_float(
			f1 float,
			f2 float(10,2),	--10位在进度范围外
			f3 float(6,2)	--6位在精度范围内
		)charset utf8;
		结果：浮点数一定会进行四舍五入(超出精度范围)，浮点数如果是因为系统进位导致整数部分超出指定的长度，那么系统也允许成立
	定点型
		绝对的保证整数部分不会被四舍五入(不会丢失精度)，小数部分有可能(理论上也不会丢失精度)
		decimal		变长，大致是每9个数字，采用4个字节存储，整数和小数分开计算，M最大是65，D最大是30，默认是10,2
		练习
		创建定点数表
		create table tb_decimal(
			f1 float(10,2),
			d1 decimal(10,2)
		)charset utf8;
		插入数据：定点数的整数部分一定不能超出长度(进位不可以)，小数部分的长度可以随意超出(系统自动四舍五入)
		insert into tb_decimal values(12345678.90,12345678.90)--有效
		insert into tb_decimal values(1234.123456,1234.123456)--小数部分超出
		insert into tb_decimal values(99999999.99,99999999.999)\
	时间日期类型
		datetime:时间日期，格式是YYYY-mm-dd HH:ii:ss，表示的是1000-9999年之间，有0值0000-00-00 00:00:00
		date:日期，格式是YYYY-mm-dd,就是datetime中的date部分
		time:时间，格式是HH:ii:ss,就是datetime中的time部分
		timestamp:时间戳，从1970年开始的YYYY-mm-dd HH:ii:ss，格式与datetime完全一致
		year:年份，两种形式，year(2)范围是1970-2069和year(4)范围是1901-2155
		练习
		创建时间日期表
		create table tb_date(
			d1 datetime,
			d2 date,
			d3 time,
			d4 timestamp,
			d5 year
		)charset utf8;
		插入数据：时间time可以是负数，而且可以是很大的负数，year可以使用2位数插入，也可以使用4位数插入
		insert into tb_date values('2015-9-28 11:50:36','2015-9-28','11:50:36','2015-9-28 11:50:36',2015)
		insert into tb_date values('2015-9-28 11:50:36','2015-9-28','-11:50:36','2015-9-28 11:50:36',2015)
		insert into tb_date values('2015-9-28 11:50:36','2015-9-28','-211:50:36','2015-9-28 11:50:36',2015)
		insert into tb_date values('2015-9-28 11:50:36','2015-9-28','-2 11:50:36','2015-9-28 11:50:36',2015) -2表示过去两天
		insert into tb_date values('2015-9-28 11:50:36','2015-9-28','11:50:36','2015-9-28 11:50:36',69) -year使用2位
		insert into tb_date values('2015-9-28 11:50:36','2015-9-28','11:50:36','2015-9-28 11:50:36',70)
		
		--timestamp:修改记录
		update tb_date set d1 = '2015-9-28 11:50:36' where `d5` = 2069;
	字符串类型
		在sql中，将字符串类型分为了，char,varchar,text,blob,enum,set
		定长字符串
			char：在定义结构的时候，就已经确定了最终数据的存储长度
			char(L):L代表length,可以存储的长度,单位为字符,最大长度可以为255
		变长字符串
			varchar:在分配空间的时候，按照最大的空间分配，但是实际上最终用了多少，是根据具体的数据来确定
			varchar(L):L表示字符长度，理论长度是65536个字符，但是会多出1-2字节来确定存储的实际长度
		如何选择定长或者变长字符串呢？
			定长的磁盘空间比较浪费，但是效率高，如果确定数据的长度基本一致，那么就选择定长
				如身份证，电话号码，手机号码等
			变长的磁盘空间都比较节省，但是效率低，如果数据不确定长度(不同的数据有变化，那么就使用边长)比如：姓名，地址等
	文本字符串
		如果数据量非常庞大，通过超过255个字符，就会使用文本字符串
		文本字符串根据存储的数据格式进行分类：text和blob
			text:存储文字
			blob:存储二进制数据(通常不用)
	枚举字符串
		枚举：enum:事先就所有可能出现的结果都设计好，实际上存储的数据必须是规定好的数据中的一个
		枚举的使用方式
			定义：enum(可能出现的元素列表);比如：enum('男','女','保密')；
			使用：存储数据，只能存储上面定义好的数据
		练习
		创建枚举表
			create table tb_enum(
				sex enum('男','女','保密')
			)charset utf8;
		插入数据：作用之一：规范数据格式，数据只能是规定中的一个
				作用之二：节省存储空间(枚举通常有一个别名：单选框)
		insert into tb_enum values('男'),('保密');--正确
		insert into tb_enum values('male');--错误，没有该数据
在mysql中，系统也是自动转换格式的，而且基本与php一样(尤其是字符串转数字)
证明字段存储的数据是数值：将数据取出来+0，就可以判断出原来的数据存的到底是字符串还是数据，如果是字符串，那么是就是0，如果不是字符串，那么就是其他的值
		找出了枚举元素的实际规律：按照元素出现的顺序，从1开始编号，内部的存储是整型表示
		例如：enum('男','女','保密') 编号依次是1,2,3
		枚举原理：枚举在进行数据规范的时候(定义的时候)系统会自动建立一个数字与枚举元素的对应关系(关系放到日志中)，然后在进行数据插入的时候，系统自动将字符串转换成对应的数字存储，然后再进行对应的数据提取的时候，系统自动将数值转换成对应的字符串显示
		注意：因为枚举实际存储的是数值，所以可直接插入数值
		注意："0"可以插入而0不能插入，"0"值插入后是一个空值，而不是null
		每个枚举值都有一个索引值， 成员值从1开始编号，空字符串的索引值为0，null值的索引值为null
		insert into tb_enum values(1);
	集合字符串
		集合和枚举很类似：实际存储的是数值而不是字符串(集合是多选的)
		集合的使用方式
			定义：set(元素列表)
			使用：可以使用元素列表中的元素(多个)，使用逗号分隔
		练习：
			创建集合表
			create table tb_set(
				hob set('篮球','足球','乒乓球','羽毛球')
			)charset utf8;
		插入数据：可使用多个元素字符串组合，也可以直接插入数据
		insert into tb_set values('篮球,羽毛球,足球')
		insert into tb_set values(3) -- 3 = 1 + 2 = 篮球 + 足球
		查看集合数据
			select hob + 0,hob from tb_set
	列属性
		真正约束字段的是数据类型，但是数据类型的约束很单一，需要一些额外的约束，来更加保证数据的合法性
		比如有：null/not null/default/primary key/foreign key/auto_increment/comment
		空属性
			两个值：null(默认的)和not null(不为空)
			虽然默认默认的，数据库基本都是字段为空，但是在实际的开发当中，我们应该避免所有的数据都不为空
		练习
			创建一个实际的表，班级表(名字，教室)
			create table tb_class(
				name varchar(10) not null,
				room varchar(10) null --不写null,也是默认为空
			)
	列描述
		列描述：comment,没有实际的含义:是专门用来描述字段，会根据表创建语句保存，是用来给程序员进行了解的
		练习：
			创建表
			create table tb_teacher(
				name varchar(10) not null comment '姓名',
				money decimal(10,2) not null
			)charset utf8;
	默认值
		某一种数据会经常性的出现某个具体的值，可以在一开始就指定，在需要真实数据的时候，用户可以选择性的使用默认值
		默认值关键字：default
		练习
			创建默认表
			create table tb_default(
				`name` varchar(10) not null,
				age tinyint unsigned default 0,
				sex enum('男','女','保密') default '男'
			)charset utf8
		默认值的生效的使用，在数据进行插入的时候，不给该字段进行赋值
	主键
		primary key主要的键，一张表中只能有一个字段可以使用对应的键，用来唯一的约束该字段里面的数据不能重复，称之为主键	
		注意：一张表中只能有最多一个主键
		增加主键
			sql操作中有多种方式可以给表添加主键，大体三种
				1.在创建表的时候，直接在字段之后primary key关键字
				 create table tb_pri(
				 	id int primary key comment 'id'
				 )charset utf8;
				2.在创建表的时候，在所有的字段之后使用primary key(主键字段列表)来创建主键，如果有多个字段，作为主键，可以是复合主键
				create table tb_pri1(
					number int comment '学号',
					course char(10) comment '课程',
					score tinyint unsigned default 60 comment '成绩',
					primary key(number,course)
				)charset utf8;
				3.当表已经创建完之后，再次额外的追加主键，可以通过修改字段属性，也可以直接追加
				alter table 表名 add primary key(列名);
		主键约束
			主键对应的字段中的数据不允许重复，一旦重复，数据操作失败
		更新主键 & 删除主键
			没有办法更新主键，主键必须先删除才能增加
			alter table 表名 drop primary key;
		主键分类
			在实际创建表的过程中，很少使用真实业务数据作为主键字段(业务主键,如学号，课程号)
			大部分的时候都是使用逻辑性字段(字段没有业务含义,值是什么都没有关系),将这种字段主键称之为逻辑主键
		自动增长
			当对应的字段不给值，或者说给默认值或者给null的时候,回自动的被系统触发，系统会从当前字段中已有的最大值进行+1操作，得到一个新的在不同的字段
			自增长通常是和主键搭配
			自增长特点：auto_increment
				1.任何一个字段想要做自增长，前提必须本身是一个索引(key的一栏要有值)
				2.自增长字段必须是数字(整数)
				3.一张表最多只能有一个自增长
			自增长使用
				当自增长被给定的值为null，或者默认的值的时候就会触发自增长
			练习
			create table tb_ai(
				id int primary key auto_increment not null default 0;
			)charset utf8;
		唯一键
			unique key
			一张表往往都有很多字段需要具有唯一性，数据不能重复，但是一张表中只能有一个主键，唯一键就解决了表中有多个字段需要唯一性的约束
			唯一键的本质与主键的本质差不多，唯一键默认的允许自动为空，而且可以多个为空(空字段不参与唯一性比较)
		增加唯一键
			基本与主键差不多，三种方案
				1.在创建表的时候就定义唯一键
				create table tb_unique(
					number char(10) unique comment '学号',
					name varchar(20) not null
				)charset utf8;
				insert into tb_unique (`name`) values ('小明');
				2.在所有的字段之后增加unique key(字段列表)复合唯一键
				create table tb_unique1(
					number char(10) not null comment '学号',
					name varchar(10),
					unique key(number)
				)charset utf8;
			注意：如果唯一键不为空那么和主键的性质一样
		唯一键约束
			唯一键与主键的本质相同：唯一的区别是唯一键默认允许为空，而且是多个空，一张表可以由多个唯一键
		删除唯一键
			alter table 表名 drop unique key;	--错误，唯一键有多个
			alter table 表名 drop index 索引名字;
		索引
			几乎所有的索引都是建立在字段之上
			索引：系统根据某种算法，将已有的数据(未来可能新增的数据)单独建立一个文件，文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录
			索引的意义：
				1.提升查询数据的效率
				2.约束数据的有效性(唯一性等)
			增加索引的前提条件，索引本身会产生索引文件(有时候有可能比数据文件还要大)，会非常耗费磁盘的空间
			如果某个字段需要作为查询的条件经常使用，那么可以使用索引(一定会想办法增加)
			如果某个字段需要进行数据的有效性约束，也可能使用索引(主键,唯一键)
			mysql中提供了多种索引
				1.主键索引：primary key
				2.唯一索引：unique key
				3.全文索引：fulltext index
				4.普通索引：index
				全文索引：针对文章内部关键字进行索引，最大的问题，在于如何确定关键字
		关系
			将实体与实体之间的关系，反应到最终数据库表的设计上来，将关系(所有的关系都是指表与表之前)分为三种：
				1.一对一
					一张表的一条记录一定只能与另外一张表的一条记录进行对应，反之亦然
				2.一对多(多对一)
					一张表中有一条记录可以对应另外一张表中的多条记录，但是反过来，另外一张表的一条记录只能对应第一张表的一条记录，这种关系就是一对多或者多对一
				3.多对多
					A表中的一条记录能够对应另外B表中的多条记录，同时B表中的一条记录也能对应A表中的多条记录
				 	多对多需要中间表的设计
		范式
			是为了解决一种数据的存储于优化的问题，保存数据的存储之后，凡是能通过关系寻找出来的数据，坚决不再重复存储，减少数据的冗余
			范式：是一种分层结构的规范，分为六层，每一次层都比上一层更加的严格，若要满足下一层的范式，前提是满足上一层范式
			六层范式：1NF....6NF
				1NF是最底层，6NF是最高层，最严格
			mysql是属于关系型数据库，有空间浪费，也是致力于节省存储空间，与范式所有解决的问题不谋而合，在设计数据库的时候，会利用到范式来指导设计，但是数据库不单是要解决空间的问题，要保证效率的问题，范式只为解决空间的问题，所以数据库的设置又不能完全按照范式的要求实现，一般情况下，只有前三种范式满足需要
			范式在数据库的设计当中具有指导意义，但是不是强制规范
			1NF:第一范式，在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前，还需要额外的处理，那么说表的设计不满足第一范式，第一范式要求字段的数据具有原子性，不可再分
			2NF:第二范式，在数据表设计的过程中，如果有复合主键(多字段主键)，且表中有字段并不是由整个主键来确定，而是依赖主键中的某个字段(主键的部分)，存在字段依赖主键部分的问题，称之为部分依赖，第二范式就是要解决表设计不允许出现部分依赖 
			3NF:要满足第三范式，必须要满足第二范式，如果一张表中，理论上讲，应该一张表中的所有字段都应该直接依赖主键(逻辑主键，代表的是业务主键)，如果在表的设计中存在一个字段，并不是直接依赖主键，而是通过某个非主键字段依赖，最终实现依赖主键，把这种不是直接依赖主键而是依赖非主键字段的依赖关系称之为非主键依赖，第三范式就是要解决传递依赖的问题
			解决方案：将6存在传递依赖的字段，以及依赖的字段本身单独取出，形成一个单独的表，然后再需要对应的信息的时候，使用对应的实体表的主键加进来
		逆规范化
			有时候，在设计表的时候，如果一张表中有几个字段需要从另一张表中获取信息，理论上讲的确可以获取到想要的数据，但是就是效率低一点，会刻意的在某些表中不去保存另外表的主键(逻辑主键)，而是直接保存想要的数据信息，这样一来查询数据的时候，一张表可以直接提供数据，而不需要多表查询(效率低)，但是会导致我们的数据冗余增加
		数据高级操作
			新增数据
				基本语法
				insert into 表名字 [(字段列表)] values (值列表);
				在插入数据的时候，假设主键对应的值已经存在，插入一定会失败
			主键冲突
				当主键存在冲突的时候，可以选择性的进行处理：更新和替换
				更新操作：
					insert into 表名  [(字段列表：包含主键)] values (值列表) on duplicate key update 字段 = 新值
				替换操作：
					replace into 表名 [(字段列表：包含主键)] values (值列表);
					注意：使用替换操作，如果主键不存在冲突，就只是插入数据
			蠕虫复制
				从已有的数据中去获取数据，然后将数据又进行新增操作，数据成倍的增加
				表创建高级操作：从已有表创建新表(复制表结构)
					create table 表名 like 数据库.表名;
				蠕虫复制：先查出数据，然后将查出的数据新增一遍
					insert into 表名[(字段列表)] select 字段 from 表名
			更新数据
				基本语法
					update 表名 set 字段 = 值 [where条件]
				高级新增语法
					update 表名 set 字段 = 值 [where条件][limit 更新数量]
			删除数据
				delete from 表名 [where条件][limit 删除数量]
				删除：如果表中存在主键自增长，那么当删除之后，自增长不会被还原
					truncate 表名;	--先删除表，后创建表
			查询数据
				基本语法
					select 字段列表/* from 表名 [where条件]
				完整语法
					select [select选项] 字段列表 [字段别名]/* from 数据源 [where 条件] [group by 子句][having 子句][order by 子句][limit 子句];
				select 选项：对查出来的结果的处理方式
					All:默认的，保留所有的结果
					distinct:去重，查出来的结果，将重复的去重
					去重	select distinct * from 表名
				字段别名：当数据进行查询出来的时候，有时候名字并不一定就满足需求(多表查询的时候，会有同名字段)
					字段名 as 别名
				数据源：数据的来源，关系型数据库都是数据表，本质上只要保证数据类似二维表，最终都可以作为数据源
					数据源分为2种：单表数据源，多表数据源，查询语句
						select * from tb_update,tb_pri
				子查询
					select * from (select * from 表名) as 别名;
				where子句：用来判断数据，筛选数据
					where子句返回结果：0或者1,0代表false,1代表true
					判断条件：
						比较运算符：>,<,>=,<=,!=,<>,=,like,between,adn,in/not
						逻辑运算符：&&(and),!!(or),!(not)
				group by子句：分组，根据某个字段分组(相同的放一组，不同的分到不同的组)
					基本语法：group by 字段名
					select * from tb_update group by name
					分组的意义：是为了统计数据(按组统计：按分组字段进行数据统计)
					函数：
						count()：统计分组后的记录数，每一组有多少的数据
							函数里面有2种参数:*或者字段名，统计的结果null不包含
						max():统计每组中的最大值
						min():统计最小值
						avg():统计平均值
						sum():统计和
					多字段分组：先根据一个字段进行分组，然后对分组后的结果再次按照其他字段进行分组
						select 字段1，字段2，count(*) from 表名 group by 字段1，字段2
					有一个函数：发可以对分组的结果中的某个字段进行字符串的链接(保留改组所有的某个字段)：group_concat(字段)
				回溯统计：with rollup:任何一个分组后的结果都有一个小组，最后都需要向上级分组汇报统计，根据当前分组的字段，这就是回溯统计：回溯统计的时候， 会将分组字段置空 
				having子句：与where子句一样，进行条件判断的
					where是针对磁盘数据进行判断，进入到内存之后，会进行分组操作，分组结果就需要having来处理，having能做where能做的几乎所有事情，但是where却不能做having能做的所有处理
					注意：having可以使用别名，而where不能使用别名，能用where的别用having
					select name,count(name) from tb_update group by name having count(name) > 15
				order by子句：排序，根据某个字段进行升序或者降序
					基本语法：order by 字段名 [asc|desc] asc是升序，desc是降序
					排序可以进行多字段排序，先根据某个字段进行排序，然后按照排序好的内部，进行某个数据的再次排序
					select * from 表名 order by 字段1,字段2
				limit子句：限制结果的语句，限制数量
					limit有两种使用方式
						1：只用来限制长度(数据量)，limit 数据量
						2：限制起始位置，限制数量，limit 起始位置,长度
			
			
		连接查询：将多张表(可以大于2张)进行记录的连接(按照某个指定的条件进行数据拼接);
			最终的结果：记录数有可能变化，字段数一定会增加(最少两张表的合并)
			分类：
				1.内连接
				2.外连接
				3.自然连接
				4.交叉连接	没什么作用
			内连接：
				inner join 其中inner关键字可以省略，从左表中取出每一条记录，去右表中与所有的记录进行匹配，匹配必须是某个条件在左表中与在右表中相同最终才会保留结果，否则不会保留
				基本语法：
					左表 [inner] join 右表 on 左表.字段 = 右表.字段
					on表示连接条件：条件字段就是代表相同的业务含义
					内连接可以没有on之后的条件，之后会形成笛卡尔积
					注意：内连接还可以使用where代替on关键字,但是没有on的效率高
			外链接：
				以某张表为主，取出里面的所有记录，然后每一条与另外一张表进行链接， 不管能不能匹配上条件，都会保留，能匹配，正确保留，不能匹配，其他表的字段都置空null
				外链接分为两种：是以某张表为主：有主表
					left join:左外连接(坐链接),以左表为主表
					right join:右外链接(右链接),以右表为主表
				基本语法
					左外连接
					select * from 左表 left join 右表 on 左表.字段 = 右表.字段
					右外链接
					select * from 右表 right join 左表 on 右表.字段 = 左表.字段
